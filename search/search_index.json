{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FastPG","text":"<p>FastPG is a lightweight asynchronous ORM for PostgreSQL applications that favour explicit SQL while still benefiting from Pydantic validation. The project wraps <code>databases</code> with a Django-inspired query API that fits naturally inside FastAPI services.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Pydantic-first models \u2013 database rows are hydrated directly into   subclasses of <code>DatabaseModel</code>, allowing you to re-use the same schemas for   request/response modelling in FastAPI.</li> <li>Async query builder \u2013 chainable <code>AsyncQuerySet</code> objects expose familiar   helpers such as <code>get</code>, <code>filter</code>, <code>count</code>, <code>update</code>, <code>delete</code>, and   <code>get_or_create</code> while emitting parameterised SQL under the hood.</li> <li>Composable filtering \u2013 the <code>Q</code> helper and Django-style lookup suffixes   provide rich filtering, including nested <code>OR</code> conditions, range comparisons,   JSON updates, and null handling.</li> <li>Relationship loading \u2013 define lightweight relations with <code>Relation</code> and   fetch related rows via <code>select_related</code> and <code>filter_related</code> in a single round   trip.</li> <li>Bulk operations and pagination \u2013 insert many rows at once with optional   conflict handling and page any queryset or raw SQL result using the bundled   paginator classes.</li> <li>Production niceties \u2013 automatic timestamp management, JSON field helpers,   configurable logging of SQL execution times, and guard rails around unsafe   updates and deletes.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>FastPG requires Python 3.9 or newer.</p> <pre><code>pip install git+https://github.com/bepragma-ai/fastpg.git\n</code></pre>"},{"location":"#environment-variables","title":"Environment variables","text":"<p>Provide PostgreSQL credentials and optional timezone configuration through the following variables:</p> <ul> <li><code>FASTPG_TZ</code> \u2013 timezone used for auto timestamp fields (defaults to <code>UTC</code>).</li> <li><code>POSTGRES_READ_*</code> and <code>POSTGRES_WRITE_*</code> \u2013 credentials used by the read and   write connection pools respectively.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Below is a minimal FastAPI application showcasing model declaration, connection management, and CRUD helpers.</p> <pre><code>from fastapi import FastAPI\nfrom fastpg import DatabaseModel, ASYNC_DB_READ, ASYNC_DB_WRITE\n\nclass Customer(DatabaseModel):\n    id: int | None = None\n    email: str\n    created_at: datetime | None = None\n\n    class Meta:\n        db_table = \"customers\"\n        primary_key = \"id\"\n        auto_generated_fields = [\"id\"]\n        auto_now_add_fields = [\"created_at\"]\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def connect_db():\n    await ASYNC_DB_READ.connect()\n    await ASYNC_DB_WRITE.connect()\n\n@app.on_event(\"shutdown\")\nasync def close_db():\n    await ASYNC_DB_READ.close()\n    await ASYNC_DB_WRITE.close()\n\n@app.get(\"/customers\")\nasync def list_customers():\n    return await Customer.async_queryset.all()\n\n@app.post(\"/customers\")\nasync def create_customer(email: str):\n    return await Customer.async_queryset.create(email=email)\n</code></pre>"},{"location":"#project-layout","title":"Project layout","text":"<ul> <li><code>fastpg/</code> \u2013 the core library (models, query builder, pagination, utilities).</li> <li><code>docs/</code> \u2013 the MkDocs site containing guides and API reference material.</li> <li><code>mkdocs.yml</code> \u2013 MkDocs configuration, including the navigation tree and theme.</li> </ul> <p>Read on for a deeper dive into models, query construction, pagination, and advanced patterns.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide walks through setting up database connections, defining your first model, and executing a few queries from a Python REPL or FastAPI application.</p>"},{"location":"getting-started/#1-configure-connections","title":"1. Configure connections","text":"<p>FastPG ships with two <code>AsyncPostgresDB</code> connection pools \u2013 one for read operations and one for write operations. Populate the required environment variables before starting your application:</p> <pre><code>export POSTGRES_READ_USER=postgres\nexport POSTGRES_READ_PASSWORD=secret\nexport POSTGRES_READ_DB=app\nexport POSTGRES_READ_HOST=127.0.0.1\nexport POSTGRES_READ_PORT=5432\n\nexport POSTGRES_WRITE_USER=postgres\nexport POSTGRES_WRITE_PASSWORD=secret\nexport POSTGRES_WRITE_DB=app\nexport POSTGRES_WRITE_HOST=127.0.0.1\nexport POSTGRES_WRITE_PORT=5432\n\n# Optional timezone for auto_now/auto_now_add fields\nexport FASTPG_TZ=UTC\n</code></pre> <p>Create the connection pools on startup and close them during shutdown. With FastAPI you can rely on the event system:</p> <pre><code>from fastapi import FastAPI\nfrom fastpg import ASYNC_DB_READ, ASYNC_DB_WRITE\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def connect_db():\n    await ASYNC_DB_READ.connect()\n    await ASYNC_DB_WRITE.connect()\n\n@app.on_event(\"shutdown\")\nasync def close_db():\n    await ASYNC_DB_READ.close()\n    await ASYNC_DB_WRITE.close()\n</code></pre> <p>For scripts or tests you can manage the lifecycle manually:</p> <pre><code>import asyncio\nfrom fastpg import ASYNC_DB_READ, ASYNC_DB_WRITE\n\nasync def bootstrap():\n    await ASYNC_DB_READ.connect()\n    await ASYNC_DB_WRITE.connect()\n\nasyncio.run(bootstrap())\n</code></pre>"},{"location":"getting-started/#2-declare-models","title":"2. Declare models","text":"<p>Models inherit from <code>DatabaseModel</code> (a <code>pydantic.BaseModel</code> subclass). Define a nested <code>Meta</code> class to configure the backing table, primary key, automatic fields, and optional relationships.</p> <pre><code>from datetime import datetime\nfrom fastpg import DatabaseModel\n\nclass Customer(DatabaseModel):\n    id: int | None = None\n    email: str\n    is_active: bool = True\n    created_at: datetime | None = None\n    updated_at: datetime | None = None\n\n    class Meta:\n        db_table = \"customers\"\n        primary_key = \"id\"\n        auto_generated_fields = [\"id\"]\n        auto_now_add_fields = [\"created_at\"]\n        auto_now_fields = [\"updated_at\"]\n</code></pre> <p>When you call <code>create</code> or <code>save</code>, FastPG will automatically populate the <code>auto_now*</code> fields using the timezone chosen in <code>FASTPG_TZ</code>.</p>"},{"location":"getting-started/#3-run-queries","title":"3. Run queries","text":"<p>Interact with the asynchronous queryset using familiar ORM-style helpers.</p> <pre><code># Insert a row and capture the returned model instance\ncustomer = await Customer.async_queryset.create(email=\"ada@example.com\")\n\n# Fetch rows\nfirst = await Customer.async_queryset.get(id=customer.id)\nactive = await Customer.async_queryset.filter(is_active=True)\ncount = await Customer.async_queryset.count()\n\n# Update and delete\nawait Customer.async_queryset.filter(id=customer.id).update(is_active=False)\nawait Customer.async_queryset.filter(id=customer.id).delete()\n</code></pre> <p>In unit tests you can use <code>pytest.mark.anyio</code> or <code>pytest-asyncio</code> to run the coroutines. The models behave like regular Pydantic models, so you can call <code>.model_dump()</code> to serialise responses or feed them directly into FastAPI route responses.</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<p>Read the concept guides for detailed explanations of metadata, filtering, relations, and pagination, or jump straight to the API reference for a method-by-method breakdown.</p>"},{"location":"api/database-models/","title":"DatabaseModel","text":"<p>Reference for the <code>DatabaseModel</code> base class and related helpers.</p>"},{"location":"api/database-models/#attributes","title":"Attributes","text":"<ul> <li><code>async_queryset</code> \u2013 descriptor returning an <code>AsyncQuerySet</code> bound to the model.</li> <li><code>model_config</code> \u2013 defaults to <code>ConfigDict(extra=\"allow\")</code>, enabling unknown   columns (useful for <code>SELECT</code> statements with computed fields).</li> </ul>"},{"location":"api/database-models/#instance-methods","title":"Instance methods","text":""},{"location":"api/database-models/#savecolumns-liststr-none-none-bool","title":"<code>save(columns: list[str] | None = None) -&gt; bool</code>","text":"<p>Update the current row in the database. When <code>columns</code> is omitted, all fields on the model are persisted. Returns <code>True</code> if at least one row was updated.</p>"},{"location":"api/database-models/#delete-bool","title":"<code>delete() -&gt; bool</code>","text":"<p>Delete the current row and return whether a row was removed.</p> <p>Both methods rely on the <code>Meta.primary_key</code> value to build the <code>WHERE</code> clause.</p>"},{"location":"api/database-models/#meta-configuration","title":"Meta configuration","text":"Option Description <code>db_table</code> Name of the table to query. Required. <code>primary_key</code> Name of the primary key column. Defaults to <code>\"id\"</code>. <code>auto_generated_fields</code> Sequence of fields removed from insert statements. <code>auto_now_add_fields</code> Sequence of fields populated once during insert. <code>auto_now_fields</code> Sequence of fields refreshed each time <code>save()</code> runs. <code>relations</code> Dict mapping relation names to <code>Relation</code> objects."},{"location":"api/database-models/#queryset-property","title":"Queryset property","text":"<p><code>queryset_property</code> is a descriptor similar to <code>@property</code> but designed for classes. It powers the <code>async_queryset</code> attribute and can be reused to expose custom querysets on your own classes if needed.</p>"},{"location":"api/queries/","title":"Query API","text":"<p>The query API comprises <code>AsyncQuerySet</code> for model-bound operations and <code>AsyncRawQuery</code> for ad-hoc SQL.</p>"},{"location":"api/queries/#asyncqueryset","title":"AsyncQuerySet","text":""},{"location":"api/queries/#creation-helpers","title":"Creation helpers","text":"Method Purpose <code>create(**kwargs)</code> Insert a single row and return the model instance. <code>bulk_create(values, skip_validations=False, on_conflict=None, ...)</code> Batch insert. Supports <code>OnConflict.DO_NOTHING</code> and <code>OnConflict.UPDATE</code>. <code>get_or_create(defaults=None, **lookup)</code> Return an existing row or create one from <code>defaults</code>."},{"location":"api/queries/#retrieval-helpers","title":"Retrieval helpers","text":"Method Purpose <code>get(**filters)</code> Fetch a single row. <code>filter(*conditions, **filters)</code> Fetch multiple rows using keyword lookups or <code>Q</code> objects. <code>all()</code> Return every row. <code>count()</code> Return the number of matching rows. <code>columns(*names)</code> Select a subset of columns. <code>order_by(**clauses)</code> Accepts a mapping of column \u2192 <code>\"ASC\"</code>/<code>\"DESC\"</code>. <code>limit(n)</code> / <code>offset(n)</code> Apply pagination clauses. <code>return_as(ReturnType)</code> Switch between model instances and dictionaries. <code>select_related(*relation_names)</code> Join related tables defined in <code>Meta.relations</code>. <code>filter_related(*conditions, **filters)</code> Apply filters to the joined tables."},{"location":"api/queries/#mutation-helpers","title":"Mutation helpers","text":"Method Purpose <code>update(**values)</code> Update rows matching the current filters. Supports arithmetic (<code>__add</code>, <code>__sub</code>, <code>__mul</code>, <code>__div</code>), JSON (<code>__jsonb</code>, <code>__jsonb_set__path</code>, <code>__jsonb_remove</code>), and interval (<code>__add_time</code>, <code>__sub_time</code>) suffixes. <code>delete()</code> Delete rows matching the filters. <p>Awaiting a queryset triggers execution. If no terminal method has been called, <code>MalformedQuerysetError</code> is raised.</p>"},{"location":"api/queries/#asyncrawquery","title":"AsyncRawQuery","text":"<p><code>AsyncRawQuery</code> wraps raw SQL statements while still providing consistent error handling.</p> Method Purpose <code>fetch(values)</code> Execute a SELECT-like statement and return dictionaries. <code>execute(values)</code> Execute a modifying statement. <code>execute_many(list_of_values)</code> Execute the same statement with multiple sets of parameters. <p>Use raw queries when you need window functions, CTEs, or other constructs that are easier to express directly in SQL.</p>"},{"location":"examples/advanced-usage/","title":"Advanced usage","text":"<p>This example mirrors the <code>shop</code> API used in the test project and shows multiple features working together: joined queries, prefetching, conflict-aware bulk writes, and multiple return types that plug straight into FastAPI responses.</p> <pre><code>from datetime import date\nfrom fastpg import (\n    DatabaseModel,\n    Relation,\n    Prefetch,\n    ReturnType,\n    OnConflict,\n    OrderBy,\n)\n\n\nclass Customer(DatabaseModel):\n    id: int | None = None\n    name: str\n    email: str\n    city: str\n\n    class Meta:\n        db_table = \"customers\"\n        auto_generated_fields = [\"id\"]\n\n\nclass Product(DatabaseModel):\n    id: int | None = None\n    sku: str\n    name: str\n    price: float\n\n    class Meta:\n        db_table = \"products\"\n        auto_generated_fields = [\"id\"]\n\n\nclass OrderItem(DatabaseModel):\n    id: int | None = None\n    order_id: int\n    product_id: int\n    quantity: int\n    unit_price: float\n\n    class Meta:\n        db_table = \"order_items\"\n        auto_generated_fields = [\"id\"]\n        relations = {\n            \"product\": Relation(Product, base_field=\"product_id\", foreign_field=\"id\"),\n        }\n\n\nclass Order(DatabaseModel):\n    id: int | None = None\n    customer_id: int\n    order_date: date\n    total_amount: float\n    status: str\n\n    class Meta:\n        db_table = \"orders\"\n        auto_generated_fields = [\"id\"]\n        relations = {\n            \"customer\": Relation(Customer, base_field=\"customer_id\", foreign_field=\"id\"),\n            \"line_items\": Relation(\n                OrderItem,\n                base_field=\"id\",\n                foreign_field=\"order_id\",\n                related_data_set_name=\"line_items\",\n            ),\n        }\n\n\n# Shared department lookup used across employee endpoints\nclass Department(DatabaseModel):\n    id: int | None = None\n    name: str\n    location: str\n\n    class Meta:\n        db_table = \"departments\"\n        auto_generated_fields = [\"id\"]\n\n\nclass Employee(DatabaseModel):\n    id: int | None = None\n    department_id: int | None\n    name: str\n    email: str\n    salary: float\n\n    class Meta:\n        db_table = \"employees\"\n        auto_generated_fields = [\"id\"]\n        relations = {\n            \"department\": Relation(Department, base_field=\"department_id\", foreign_field=\"id\"),\n        }\n\n\n# 1. Bulk upsert a batch of products for catalogue maintenance\nawait Product.async_queryset.bulk_create(\n    [\n        {\"sku\": \"SKU-100\", \"name\": \"Noise Cancelling Headphones\", \"price\": 249.0},\n        {\"sku\": \"SKU-101\", \"name\": \"Wireless Mouse\", \"price\": 39.0},\n    ],\n    on_conflict=OnConflict.UPDATE,\n    conflict_target=[\"sku\"],\n    update_fields=[\"name\", \"price\"],\n)\n\n\n# 2. Serve employees with joined department data for a dashboard\nemployees = await Employee.async_queryset.select_related(\"department\").order_by(\n    salary=OrderBy.DESCENDING\n)\n\n\n# 3. Build a nested order payload using select_related and prefetch_related\norders = await (\n    Order.async_queryset\n    .select_related(\"customer\")\n    .prefetch_related(\n        Prefetch(\n            \"line_items\",\n            OrderItem.async_queryset.select_related(\"product\").all(),\n        )\n    )\n    .filter(status=\"processing\")\n)\n\n\n# 4. Serialise the same query as dictionaries when JSON is preferred\norders_payload = await (\n    Order.async_queryset\n    .prefetch_related(\n        Prefetch(\n            \"line_items\",\n            OrderItem.async_queryset.select_related(\"product\").all(),\n        )\n    )\n    .filter(status=\"processing\")\n    .return_as(ReturnType.DICT)\n)\n</code></pre> <p>The resulting structures can be returned directly from FastAPI endpoints, just like the demo routes in <code>test_project/app/api/endpoints/shop_api.py</code>. Bulk operations keep product data fresh, <code>select_related</code> joins customer details to an order, and <code>prefetch_related</code> assembles a rich response for nested collections without hand-written SQL.</p>"},{"location":"examples/advanced-usage/#managing-transactions-for-multi-step-writes","title":"Managing transactions for multi-step writes","text":"<p>When a write spans multiple tables, wrap it in a database transaction so either all steps succeed or none do. The shop demo exposes this flow through the <code>create_department_with_employees</code> endpoint, which uses <code>ASYNC_DB_WRITE</code> to wrap department creation and employee inserts in a single unit of work.</p> <pre><code>from fastpg import ASYNC_DB_WRITE\n\n\nasync def create_department_with_employees(department_data, employees_data):\n    async with ASYNC_DB_WRITE.transaction():\n        department = await Department.async_queryset.create(**department_data)\n        for emp in employees_data:\n            emp[\"department_id\"] = department.id\n            await Employee.async_queryset.create(**emp)\n    return department\n</code></pre> <p><code>ASYNC_DB_WRITE.transaction()</code> supports async context managers, decorators, or manual begin/commit calls. In every mode, FastPG will roll back the transaction if an exception is raised so partial writes never hit the database.</p>"},{"location":"examples/basic-usage/","title":"Basic usage","text":"<p>The shop demo models provide an end-to-end tour of FastPG. The example below shows how to model inventory, load related data, and keep products in sync from a bulk import while staying entirely asynchronous.</p> <pre><code>from fastpg import DatabaseModel, AsyncPaginator, OnConflict, OrderBy, ReturnType\n\n\nclass Category(DatabaseModel):\n    id: int | None = None\n    name: str\n    description: str\n\n    class Meta:\n        db_table = \"categories\"\n        auto_generated_fields = [\"id\"]\n\n\nclass Product(DatabaseModel):\n    id: int | None = None\n    sku: str\n    name: str\n    category_id: int | None = None\n    price: float\n    stock_quantity: int\n\n    class Meta:\n        db_table = \"products\"\n        auto_generated_fields = [\"id\"]\n\n\n# Insert or update a catalogue in one call\npayload = [\n    {\n        \"sku\": \"HAT-001\",\n        \"name\": \"Logo Baseball Cap\",\n        \"category_id\": 1,\n        \"price\": 19.99,\n        \"stock_quantity\": 50,\n    },\n    {\n        \"sku\": \"HAT-002\",\n        \"name\": \"Wool Beanie\",\n        \"category_id\": 1,\n        \"price\": 24.99,\n        \"stock_quantity\": 80,\n    },\n]\n\nawait Product.async_queryset.bulk_create(\n    payload,\n    on_conflict=OnConflict.UPDATE,\n    conflict_target=[\"sku\"],\n    update_fields=[\"name\", \"category_id\", \"price\", \"stock_quantity\"],\n)\n\n# Read back the range of products, sorted by price descending\nproducts = await Product.async_queryset.order_by(price=OrderBy.DESCENDING)\n\n# Pull a single product as a dict for light-weight serialisation\nproduct_data = await (\n    Product.async_queryset\n    .filter(sku=\"HAT-001\")\n    .return_as(ReturnType.DICT)\n)\n\n# Paginate the catalogue for an API response\nqueryset = Product.async_queryset.all().order_by(name=OrderBy.ASCENDING)\npaginator = AsyncPaginator(page_size=10, queryset=queryset)\npage1 = await paginator.get_page(1)\n</code></pre> <p><code>page1[\"results\"]</code> contains a list of <code>Product</code> instances. The paginator metadata (total count, page boundaries) lives under <code>page1[\"results_paginator\"]</code>, which can be returned directly from a FastAPI route.</p>"},{"location":"guides/models/","title":"Models","text":"<p><code>DatabaseModel</code> is the heart of FastPG. It builds on <code>pydantic.BaseModel</code>, so your database records immediately benefit from Pydantic validation, type hints, and serialisation helpers.</p>"},{"location":"guides/models/#declaring-a-model","title":"Declaring a model","text":"<pre><code>from datetime import datetime\nfrom fastpg import DatabaseModel\n\nclass Invoice(DatabaseModel):\n    id: int | None = None\n    customer_id: int\n    total: float\n    status: str = \"draft\"\n    issued_at: datetime | None = None\n    updated_at: datetime | None = None\n\n    class Meta:\n        db_table = \"invoices\"\n        primary_key = \"id\"\n        auto_generated_fields = [\"id\"]\n        auto_now_add_fields = [\"issued_at\"]\n        auto_now_fields = [\"updated_at\"]\n</code></pre> <p>All fields defined on the model map directly to columns in the backing table. Default values and <code>Field</code> metadata behave just like in a regular Pydantic model.</p>"},{"location":"guides/models/#meta-options","title":"Meta options","text":"Attribute Required Description <code>db_table</code> \u2705 Name of the table FastPG should query. <code>primary_key</code> \u274c (defaults to <code>\"id\"</code>) Column used to uniquely identify rows. <code>auto_generated_fields</code> \u274c Fields that should be omitted on insert (e.g. serial IDs). <code>auto_now_add_fields</code> \u274c Fields populated with the current timestamp when inserting. <code>auto_now_fields</code> \u274c Fields refreshed with the current timestamp on <code>save()</code>. <code>relations</code> \u274c Mapping of relation name \u2192 <code>Relation</code> describing joins. <p>The automatic timestamp hooks draw the timezone from the <code>FASTPG_TZ</code> environment variable. Invalid or missing values fall back to UTC.</p>"},{"location":"guides/models/#accessing-the-queryset","title":"Accessing the queryset","text":"<p>Every <code>DatabaseModel</code> exposes an <code>async_queryset</code> descriptor that returns an <code>AsyncQuerySet</code> bound to the model. The queryset is safe to reuse across requests because each query call produces a new instance under the hood.</p> <pre><code>invoices = await Invoice.async_queryset.filter(status=\"sent\")\n</code></pre>"},{"location":"guides/models/#instance-helpers","title":"Instance helpers","text":"<p>Use <code>save()</code> to persist modifications to a model instance. Only the columns you pass will be updated; if omitted, the method updates every field present on the model.</p> <pre><code>invoice = await Invoice.async_queryset.get(id=123)\ninvoice.status = \"paid\"\nawait invoice.save(columns=[\"status\"])\n</code></pre> <p><code>delete()</code> removes the row matching the model's primary key and returns a boolean indicating whether a record was deleted.</p> <pre><code>invoice = await Invoice.async_queryset.get(id=123)\nawait invoice.delete()\n</code></pre>"},{"location":"guides/models/#working-with-json-columns","title":"Working with JSON columns","text":"<p>If a column stores JSON, annotate it with <code>JsonData</code> for transparent serialisation and deserialisation. FastPG will convert Python objects to JSON strings when writing and back into Python objects when reading.</p> <pre><code>from fastpg import JsonData\n\nclass Event(DatabaseModel):\n    id: int | None = None\n    payload: JsonData\n\n    class Meta:\n        db_table = \"events\"\n</code></pre>"},{"location":"guides/models/#relationships","title":"Relationships","text":"<p>Attach lightweight relationships via the <code>Meta.relations</code> dictionary. Each entry contains a <code>Relation</code> object that specifies how the current table relates to another model. See the relationships guide for details on querying related rows.</p>"},{"location":"guides/pagination/","title":"Pagination","text":"<p>FastPG includes two helper classes for paginating results: <code>AsyncPaginator</code> for querysets and <code>RawQueryAsyncPaginator</code> for raw SQL queries. Both expose a common API that returns a payload containing the results and metadata about the current page.</p>"},{"location":"guides/pagination/#paginating-querysets","title":"Paginating querysets","text":"<pre><code>from fastpg import AsyncPaginator\n\nqueryset = Customer.async_queryset.filter(is_active=True).order_by(created_at=\"DESC\")\npaginator = AsyncPaginator(page_size=20, queryset=queryset)\n\nfirst_page = await paginator.get_page(page=1)\nsecond_page = await paginator.get_next_page()\n</code></pre> <p>The response structure looks like this:</p> <pre><code>{\n  \"results\": [...],\n  \"results_paginator\": {\n    \"number\": 1,\n    \"page_size\": 20,\n    \"has_next\": true,\n    \"has_previous\": false,\n    \"start_index\": 0,\n    \"end_index\": 20\n  }\n}\n</code></pre> <p><code>get_next_page()</code> and <code>get_previous_page()</code> automatically adjust the current page number and call <code>get_page()</code> internally. If you request a page number less than 1, the paginator raises <code>InvalidPageError</code>.</p>"},{"location":"guides/pagination/#paginating-raw-sql","title":"Paginating raw SQL","text":"<p>Sometimes you may want to page the results of a handcrafted SQL statement. Use <code>RawQueryAsyncPaginator</code> with a query string that contains <code>{limit}</code> and <code>{offset}</code> placeholders.</p> <pre><code>from fastpg import RawQueryAsyncPaginator\n\nquery = \"\"\"\nSELECT id, email\nFROM customers\nWHERE created_at &gt;= :start\nORDER BY created_at DESC\nLIMIT {limit} OFFSET {offset}\n\"\"\"\n\npaginator = RawQueryAsyncPaginator(\n    page_size=50,\n    query=query,\n    values={\"start\": window_start},\n)\npage = await paginator.get_page(1)\n</code></pre> <p>Optionally provide a <code>serializer</code> callable to transform the records returned from the database before they are included in the paginator payload.</p>"},{"location":"guides/querysets/","title":"Querysets","text":"<p><code>AsyncQuerySet</code> offers a fluent interface for building SQL queries. Each chain of methods produces a lazily evaluated queryset that executes when awaited.</p>"},{"location":"guides/querysets/#core-retrieval-methods","title":"Core retrieval methods","text":"Method Description <code>get(**kwargs)</code> Fetch a single row. Raises <code>DoesNotExist</code> or <code>MultipleRecordsFound</code> when the result is not unique. <code>filter(**kwargs)</code> Return all rows that match the provided filters. <code>all()</code> Select every row from the table. <code>count()</code> Return the number of rows matching the filters without materialising the result set. <pre><code># Fetch a single customer\nfrom app.schemas.shop import Customer\n\ncustomer = await Customer.async_queryset.get(id=42)\n\n# Chain filters and ordering\nfrom fastpg import OrderBy\n\nrecent = await (\n    Customer.async_queryset\n    .filter(is_active=True)\n    .order_by(created_at=OrderBy.DESCENDING)\n    .limit(20)\n)\n</code></pre> <p>Use <code>columns(\"id\", \"email\")</code> to narrow the selected fields, <code>limit(n)</code> to restrict the number of rows, <code>offset(n)</code> for pagination, and <code>order_by(field=\"ASC\")</code> to control sorting.</p>"},{"location":"guides/querysets/#lookup-expressions","title":"Lookup expressions","text":"<p>Filters accept Django-style suffixes separated by <code>__</code>. A few highlights:</p> <ul> <li><code>field=value</code> \u2013 exact match</li> <li><code>field__gt=value</code>, <code>field__lt=value</code>, <code>field__gte=value</code>, <code>field__lte=value</code></li> <li><code>field__ne=value</code> \u2013 inequality</li> <li><code>field__in=[...]</code> \u2013 membership (must be a non-empty list)</li> <li><code>field__isnull=True/False</code></li> <li><code>field__contains</code>, <code>field__icontains</code>, <code>startswith</code>, <code>istartswith</code>, <code>endswith</code>, <code>iendswith</code></li> </ul> <p>Combine expressions with <code>Q</code> objects to build complex <code>OR</code> clauses:</p> <pre><code>from fastpg import Q\n\nadults = Q(age__gte=18)\nrecent = Q(created_at__gte=window_start)\n\nresults = await Customer.async_queryset.filter(adults | recent)\n</code></pre>"},{"location":"guides/querysets/#mutating-queries","title":"Mutating queries","text":"<ul> <li><code>create(**kwargs)</code> \u2013 insert a row and return the new model instance. FastPG   automatically removes auto-generated fields and populates <code>auto_now_add</code>   fields before writing.</li> <li><code>bulk_create(values, skip_validations=False, on_conflict=None, ...)</code> \u2013 insert   many rows efficiently. When <code>on_conflict</code> is <code>OnConflict.DO_NOTHING</code> or   <code>OnConflict.UPDATE</code>, FastPG will emit the relevant <code>ON CONFLICT</code> clause.</li> <li><code>get_or_create(defaults=None, **lookup)</code> \u2013 fetch a row matching the lookup or   insert a new one using <code>defaults</code>.</li> <li><code>update_or_create(defaults, **lookup)</code> \u2013 update a row with <code>defaults</code> when it   exists, or create it when it does not. Returns a tuple of   <code>(instance, created)</code> where <code>created</code> is a boolean.</li> <li><code>update(**kwargs)</code> \u2013 set or increment fields. Special suffixes include   <code>__add</code>, <code>__sub</code>, <code>__mul</code>, <code>__div</code>, <code>__jsonb</code>, <code>__jsonb_set__path[__type]</code>,   <code>__jsonb_remove</code> for JSON columns, and <code>__add_time</code>/<code>__sub_time</code> for   timestamp arithmetic.</li> <li><code>delete()</code> \u2013 remove rows that match the current filters.</li> </ul> <p>Both <code>update</code> and <code>delete</code> require a filter; FastPG raises <code>UnrestrictedUpdateError</code> or <code>UnrestrictedDeleteError</code> if you attempt to call them without a <code>WHERE</code> clause.</p>"},{"location":"guides/querysets/#update-suffix-examples","title":"Update suffix examples","text":"<p>Update suffixes let you express common mutations directly in SQL without round-tripping values through Python. A few practical examples from the shop demo API:</p> <pre><code># Bump inventory without fetching the row first\nawait Product.async_queryset.filter(id=product_id).update(\n    stock_quantity__add=5,\n)\n\n# Remove a JSON field while leaving the rest of the document intact\nawait Product.async_queryset.filter(id=product_id).update(\n    properties__jsonb_remove=\"deprecated_flag\",\n)\n\n# Extend or shorten a timestamp by a PostgreSQL interval literal\nawait Product.async_queryset.filter(\n    id=product_id,\n    offer_expires_at__isnull=False,\n).update(\n    offer_expires_at__add_time=\"3 days\",   # use __sub_time to shorten\n)\n</code></pre> <ul> <li><code>__jsonb_remove</code> subtracts a key (or path) from a JSON/JSONB column.</li> <li><code>__add_time</code> and <code>__sub_time</code> apply an interval string (for example, \"2 hours\"   or \"5 days\") to timestamp fields without recalculating them in Python.</li> </ul>"},{"location":"guides/querysets/#upsert-with-update_or_create","title":"Upsert with <code>update_or_create</code>","text":"<p><code>update_or_create</code> is helpful when an API payload might refer to an existing record by natural keys but you still want a single call to update or insert it. It combines a lookup, update, and create into one step and returns a tuple of the resulting model instance and a <code>created</code> flag.</p> <pre><code>product, created = await Product.async_queryset.update_or_create(\n    id=payload[\"id\"],\n    sku=payload[\"sku\"],\n    defaults={\n        \"name\": payload[\"name\"],\n        \"category_id\": payload[\"category_id\"],\n        \"price\": payload[\"price\"],\n        \"stock_quantity\": payload[\"stock_quantity\"],\n    },\n)\n\nif created:\n    log.info(\"Inserted a new product\")\nelse:\n    log.info(\"Updated existing product %s\", product.id)\n</code></pre> <p>The shop demo endpoint <code>update_or_create_product</code> in <code>test_project/app/api/endpoints/shop_api.py</code> uses this pattern when syncing products.</p>"},{"location":"guides/querysets/#changing-the-return-format","title":"Changing the return format","text":"<p>By default, querysets yield model instances. Call <code>return_as(ReturnType.MODEL_INSTANCE)</code> explicitly when you want to ensure nested relations are hydrated as models, or <code>return_as(ReturnType.DICT)</code> to obtain a list of dictionaries for lightweight serialisation.</p> <pre><code>from fastpg import ReturnType\n\nraw_rows = await (\n    Customer.async_queryset\n    .filter(is_active=True)\n    .return_as(ReturnType.DICT)\n)\n</code></pre>"},{"location":"guides/querysets/#related-lookups","title":"Related lookups","text":"<p>When <code>Meta.relations</code> is defined, you can fetch related rows in a single round-trip using <code>select_related()</code> and <code>filter_related()</code>. For large collections reach for <code>prefetch_related()</code> with a <code>Prefetch</code> descriptor.</p> <pre><code>from fastpg import Prefetch\nfrom app.schemas.shop import OrderItem\n\n\norders = await (\n    Customer.async_queryset\n    .select_related(\"orders\")\n    .filter(id=1)\n    .filter_related(orders__status=\"open\")\n    .prefetch_related(\n        Prefetch(\"line_items\", OrderItem.async_queryset.select_related(\"product\").all())\n    )\n)\n</code></pre> <p>The related records are hydrated into the attribute named after the relation. See the relationships guide for a detailed example.</p>"},{"location":"guides/querysets/#executing-custom-sql","title":"Executing custom SQL","text":"<p>For cases where the queryset API is too limiting, use <code>execute_raw_query()</code> to run arbitrary SQL and still benefit from the queryset execution helpers.</p> <pre><code>rows = await Customer.async_queryset.execute_raw_query(\n    \"SELECT id, email FROM customers WHERE created_at &gt;= :start\",\n    {\"start\": window_start},\n)\n</code></pre> <p>Alternatively, instantiate <code>AsyncRawQuery</code> directly for standalone read or write operations outside of a model context.</p>"},{"location":"guides/relationships/","title":"Relationships","text":"<p>FastPG keeps relationship mapping simple: declare the join metadata yourself and let <code>AsyncQuerySet</code> handle the SQL. This approach avoids heavy ORM abstractions while still enabling eager loading.</p>"},{"location":"guides/relationships/#defining-relations","title":"Defining relations","text":"<p>Use the <code>Relation</code> helper in a model's <code>Meta.relations</code> dictionary. Each entry maps an attribute name to a <code>Relation</code> describing the related model and the join keys. The shop demo bundles these patterns together for employees that belong to departments.</p> <pre><code>from fastpg import DatabaseModel, Relation\n\n\nclass Department(DatabaseModel):\n    id: int | None = None\n    name: str\n    location: str\n\n    class Meta:\n        db_table = \"departments\"\n        primary_key = \"id\"\n        auto_generated_fields = [\"id\"]\n\n\nclass Employee(DatabaseModel):\n    id: int | None = None\n    department_id: int | None\n    name: str\n    email: str\n    salary: float\n\n    class Meta:\n        db_table = \"employees\"\n        primary_key = \"id\"\n        auto_generated_fields = [\"id\"]\n        relations = {\n            \"department\": Relation(\n                Department,\n                base_field=\"department_id\",\n                foreign_field=\"id\",\n            )\n        }\n</code></pre> <p>The <code>Relation</code> definition instructs FastPG how to join the two tables. When the relation name matches the attribute you want on the model (<code>department</code> in this case) you can skip <code>related_data_set_name</code>; FastPG uses the relation key by default.</p>"},{"location":"guides/relationships/#fetching-related-rows","title":"Fetching related rows","text":"<p>Call <code>select_related</code> to join the related table and hydrate the nested models. In the FastAPI demo endpoint we retrieve department data alongside employees and filter on both the base and related models:</p> <pre><code>from fastapi import APIRouter\nfrom fastpg import OrderBy\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/employees\")\nasync def get_employees(department: str | None = None, salary: float | None = None):\n    employees = Employee.async_queryset.select_related(\"department\").all()\n    if salary:\n        employees = employees.filter(salary__gte=salary)\n    if department:\n        employees = employees.filter_related(department__name=department)\n    return await employees.order_by(salary=OrderBy.DESCENDING)\n</code></pre> <p><code>select_related</code> works with any queryset method (<code>get</code>, <code>filter</code>, <code>all</code>). When you need to restrict the related rows, chain <code>filter_related</code> after <code>select_related</code>. Related filters use the same lookup expressions as normal filters, prefixed with <code>&lt;relation_name&gt;__</code>.</p> <pre><code>sales_team = await (\n    Employee.async_queryset\n    .select_related(\"department\")\n    .filter_related(department__name__icontains=\"sales\")\n    .order_by(name=OrderBy.ASCENDING)\n)\n</code></pre> <p>The related queryset accepts the same lookup expressions as the primary queryset, enabling flexible joins without manual SQL.</p>"},{"location":"guides/relationships/#working-with-the-results","title":"Working with the results","text":"<p>FastPG de-duplicates the main records before constructing model instances. Each parent object receives a list of fully instantiated related models. If no rows are found on the right side of the join, the list is empty.</p> <p>Because the models are normal Pydantic instances you can serialise them using <code>.model_dump()</code> or pass them straight to FastAPI responses.</p>"},{"location":"guides/relationships/#prefetching-child-collections","title":"Prefetching child collections","text":"<p>When a parent model owns many children (orders with line items, departments with employees) prefer <code>prefetch_related</code>. It executes the base query first and then populates the collections with a second query per relation, keeping the SQL readable and avoiding cartesian explosions.</p> <pre><code>from fastpg import Prefetch, ReturnType\n\n\n@router.get(\"/departments\")\nasync def get_departments():\n    departments = await Department.async_queryset.prefetch_related(\n        Prefetch(\"employees\", Employee.async_queryset.all())\n    ).all().return_as(ReturnType.DICT)\n    return departments\n</code></pre> <p>Each <code>Prefetch</code> requires the attribute name and a queryset that knows how to fetch the related objects. FastPG matches records automatically by comparing the primary key of the base objects (<code>id</code>) with the foreign key on the related ones (<code>department_id</code> in this example).</p>"},{"location":"reference/errors/","title":"Errors","text":"<p>FastPG raises descriptive exceptions to help you handle edge cases gracefully.</p>"},{"location":"reference/errors/#configuration-errors","title":"Configuration errors","text":"<ul> <li><code>MalformedMetaError(model_name)</code> \u2013 raised when a model's <code>Meta</code> class is   missing required attributes such as <code>db_table</code> or <code>primary_key</code>.</li> <li><code>MalformedQuerysetError(model_name)</code> \u2013 raised when a queryset is awaited   without calling one of the terminal methods (<code>get</code>, <code>filter</code>, <code>all</code>, <code>count</code>,   <code>update</code>, or <code>delete</code>).</li> </ul>"},{"location":"reference/errors/#query-construction","title":"Query construction","text":"<ul> <li><code>InvalidINClauseValueError</code> \u2013 raised when the value supplied to <code>__in</code> is not a   non-empty list.</li> <li><code>UnsupportedOperatorError</code> \u2013 raised when an unknown lookup suffix is used in a   filter or update expression.</li> </ul>"},{"location":"reference/errors/#result-cardinality","title":"Result cardinality","text":"<ul> <li><code>DoesNotExist</code> \u2013 thrown by <code>get</code> when no row matches the filters.</li> <li><code>MultipleRecordsFound</code> \u2013 thrown by <code>get</code> when more than one row matches.</li> </ul>"},{"location":"reference/errors/#mutations","title":"Mutations","text":"<ul> <li><code>DuplicateKeyDatabaseError</code> \u2013 wraps PostgreSQL's <code>23505</code> errors during insert   or update operations.</li> <li><code>NothingToCreateError</code> \u2013 raised when <code>bulk_create</code> is called with an empty   payload.</li> <li><code>UnrestrictedUpdateError</code> / <code>UnrestrictedDeleteError</code> \u2013 protect against   accidental full-table updates or deletes by requiring a filter clause.</li> </ul>"},{"location":"reference/errors/#pagination","title":"Pagination","text":"<ul> <li><code>InvalidPageError</code> \u2013 raised when requesting a page number less than 1.</li> </ul>"},{"location":"reference/errors/#database-level-failures","title":"Database-level failures","text":"<ul> <li><code>DatabaseError</code> \u2013 a generic wrapper capturing the underlying exception type   and SQLSTATE code. Querysets and raw queries raise this when the database   driver fails or returns an error outside of the specialised cases above.</li> </ul> <p>Handle these exceptions in your application code to return meaningful error responses or trigger compensating actions.</p>"},{"location":"reference/json-fields/","title":"JSON fields","text":"<p>FastPG provides utilities for working with JSON columns stored in PostgreSQL.</p>"},{"location":"reference/json-fields/#jsondata","title":"<code>JsonData</code>","text":"<p>Annotate model attributes with <code>JsonData</code> to enable automatic serialisation and deserialisation. The type is defined as an annotated Pydantic <code>Json</code> field with custom validators and serializers.</p> <pre><code>from fastpg import DatabaseModel, JsonData\n\nclass AuditLog(DatabaseModel):\n    id: int | None = None\n    payload: JsonData\n\n    class Meta:\n        db_table = \"audit_logs\"\n</code></pre> <p>When a model instance is persisted, FastPG serialises dictionaries and lists to JSON strings using a custom encoder that understands <code>datetime</code> objects. When reading from the database, JSON strings are converted back to Python objects.</p>"},{"location":"reference/json-fields/#helper-functions","title":"Helper functions","text":"<ul> <li><code>json_str_to_dict(value)</code> \u2013 convert JSON strings into dictionaries; used   internally when hydrating models.</li> <li><code>validate_json_data(value)</code> \u2013 serialise Python objects before insert/update.</li> <li><code>serialize_json_data(value, info)</code> \u2013 honour the <code>db_write</code> context flag when   deciding whether to serialise the data.</li> </ul> <p>You can use these helpers directly if you need to customise behaviour in your own serializers or background tasks.</p>"},{"location":"reference/preprocessors/","title":"Preprocessors","text":"<p>FastPG applies a handful of pre-save hooks to keep timestamp fields up to date without littering your application code with <code>datetime.utcnow()</code> calls.</p>"},{"location":"reference/preprocessors/#timezone-detection","title":"Timezone detection","text":"<p>The library reads the <code>FASTPG_TZ</code> environment variable to determine which timezone should be used when populating automatic timestamp fields. If the value is missing or invalid, UTC is used as a safe default.</p>"},{"location":"reference/preprocessors/#creation-hooks","title":"Creation hooks","text":"<p><code>PreCreateProcessors.model_obj_populate_auto_now_add_fields(model_obj)</code></p> <ul> <li>Populates each field listed in <code>Meta.auto_now_add_fields</code> with the current   timezone-aware datetime.</li> <li>Invoked automatically during <code>create</code> and <code>bulk_create</code> operations before the   model is serialised and inserted.</li> </ul> <p><code>PreCreateProcessors.model_dict_populate_auto_generated_fields(model_dict, model_cls)</code></p> <ul> <li>Removes any fields marked in <code>Meta.auto_generated_fields</code> from the payload   before inserting, allowing PostgreSQL defaults or sequences to take over.</li> </ul>"},{"location":"reference/preprocessors/#update-hooks","title":"Update hooks","text":"<p><code>PreSaveProcessors.model_obj_populate_auto_now_fields(model_obj)</code></p> <ul> <li>Populates each field listed in <code>Meta.auto_now_fields</code> prior to calling <code>save</code>.</li> <li>Ensures updated timestamps always reflect the time of the update, regardless   of what the caller set on the model instance.</li> </ul> <p>These hooks are automatically wired into the ORM, but they can also be called manually if you need similar behaviour in custom scripts.</p>"},{"location":"reference/settings/","title":"Settings and logging","text":"<p>FastPG relies on a handful of environment variables to configure database connections, timestamp behaviour, and SQL logging.</p>"},{"location":"reference/settings/#database-connections","title":"Database connections","text":"<p>Two connection pools are created automatically when you import <code>fastpg.db</code>:</p> <ul> <li><code>ASYNC_DB_READ</code> \u2013 read-only operations</li> <li><code>ASYNC_DB_WRITE</code> \u2013 write operations</li> </ul> <p>Provide credentials via the following environment variables:</p> Variable Description <code>POSTGRES_READ_USER</code> / <code>POSTGRES_WRITE_USER</code> Database user for each pool. <code>POSTGRES_READ_PASSWORD</code> / <code>POSTGRES_WRITE_PASSWORD</code> Password for the user. <code>POSTGRES_READ_DB</code> / <code>POSTGRES_WRITE_DB</code> Database name. <code>POSTGRES_READ_HOST</code> / <code>POSTGRES_WRITE_HOST</code> Hostname or IP address. <code>POSTGRES_READ_PORT</code> / <code>POSTGRES_WRITE_PORT</code> Port number. <p>Connections are established lazily when you call <code>connect()</code>. Each pool uses an asyncpg-powered DSN with a minimum of two connections and a maximum of five.</p>"},{"location":"reference/settings/#timezone","title":"Timezone","text":"<p><code>FASTPG_TZ</code> controls the timezone for automatic timestamp fields. Unknown values fall back to UTC.</p>"},{"location":"reference/settings/#sql-logging","title":"SQL logging","text":"<p>Set <code>LOG_DB_QUERIES=true</code> to log the SQL statement and execution time for every query executed through <code>AsyncPostgresDB</code>. The logger categorises durations into &lt;1s, 1\u20135s, 5\u201310s, and &gt;10s buckets and prefixes the message with the upper-cased <code>PROJECT_NAME</code> (defaults to <code>UNNAMED</code>). Use standard Python logging configuration to route these logs to stdout, files, or observability systems.</p>"}]}